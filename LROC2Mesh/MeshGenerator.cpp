#include "MeshGenerator.h"
#include <iostream>
#include <fstream>

#include <sstream> 
#include <omp.h>  

#include <chrono>
#include <iomanip> // Required for std::setprecision

void MeshGenerator::writeVertices(std::ofstream& file, const DigitalTerrainModel& dtm, double zScale, std::vector<int>& vertexMap) const
{
	std::cout << ">>>> writing vertices" << std::endl;

	const double* geoTransform = dtm.getGeoTransform();
	const float noDataValue = dtm.getNoDataValue();
	int width = dtm.getWidth();
	int height = dtm.getHeight();

	std::vector<float> scanlineBuffer(width);

	int currentVertexIndex = 1;

	for (int y = 0; y < height; ++y)
	{
		if (!dtm.readScanline(y, scanlineBuffer))
		{
			std::cerr << ">>>> failed to read scanline " << y << std::endl;
			continue;
		}

		for (int x = 0; x < width; ++x)
		{
			float elevation = scanlineBuffer[x];
			if (elevation == noDataValue)
				continue; // Skip NoData values

			// Calculate the geographic coordinates
			double worldX = geoTransform[0] + x * geoTransform[1] + y * geoTransform[2];
			double worldY = geoTransform[3] + x * geoTransform[4] + y * geoTransform[5];
			double worldZ = elevation * zScale;

            file << "v " << worldX << " " << worldY << " " << worldZ << "\n";
			vertexMap[y * width + x] = currentVertexIndex++;
		}

		if ((y + 1) % 100000 == 0)
		{
			std::cout << ">>>> processed " << (y + 1) << " of " << height << " lines for vertices.\n";
		}
	}

	file << "# Total vertices: " << (currentVertexIndex - 1) << "\n\n";
}

void MeshGenerator::writeFaces(std::ofstream& file, const DigitalTerrainModel& dtm, const std::vector<int>& vertexMap) const
{
	std::cout << ">>>> writing faces" << std::endl;

	const int width = dtm.getWidth();
	const int height = dtm.getHeight();
	long long faceCount = 0; // to keep millions of faces

	// a vector of stringstreams, each thread could write to its own stream
	// this avoids race condition on the single output file stream
	std::vector<std::stringstream> privateBuffers;

	#pragma omp parallel
	{
		// Each thread gets its own private stringstream buffer.
		// This is crucial to prevent multiple threads from writing to the same memory at once.
		std::stringstream localBuffer;

		// Distribute the 'y' loop iterations among the available threads.
		// 'schedule(static)' divides the work into contiguous (adjacent) chunks and gives one to each thread.
		// 'reduction(+:totalFaceCount)' creates a private copy of totalFaceCount for each thread,
		// and safely combines them (sums them up) at the end of the parallel region.
		#pragma omp for schedule(static) reduction(+:faceCount)
		for (int y = 0; y < height - 1; ++y)
		{
			for (int x = 0; x < width - 1; ++x)
			{
				size_t i = static_cast<size_t>(y) * width + x;
				int v1 = vertexMap[i];
				int v2 = vertexMap[i + 1]; // right neighbor
				int v3 = vertexMap[i + width]; // bottom neighbor
				int v4 = vertexMap[i + width + 1]; // bottom right neighbor

				if (v1 == 0 || v2 == 0 || v3 == 0 || v4 == 0)
					continue;

				// Write the output to the thread's private local buffer, not the main file stream.
				// two triangles for the quad formed by the vertices
				localBuffer << "f " << v1 << " " << v3 << " " << v4 << "\n";
				localBuffer << "f " << v1 << " " << v4 << " " << v2 << "\n";
				faceCount += 2;
			}
		}

		// A critical section ensures that only one thread at a time can execute this block.
		// This is necessary to safely push the thread's local buffer into the shared 'privateBuffers' vector.
		#pragma omp critical
		{
			// std::move is used for efficiency, avoiding a potentially expensive copy of the stringstream.
			privateBuffers.push_back(std::move(localBuffer));
		}
	}

	// At this point, all parallel processing is complete.
	// Now, write the contents of each thread's buffer to the main file stream sequentially.
	// This ensures the output in the final file remains in the correct order.
	std::cout << ">>>> flushing parallel buffers to file" << std::endl;
	for (const auto& buffer : privateBuffers)
	{
		file << buffer.rdbuf();
	}

	file << "# Total faces: " << faceCount << "\n";
}

void MeshGenerator::generateMesh(const DigitalTerrainModel& dtm, const std::string& outputFilePath, double zScale) const
{
	auto total_start = std::chrono::high_resolution_clock::now();

	std::cout << ">>>> generating mesh for DTM" << std::endl;
	std::ofstream file(outputFilePath);
	if (!file.is_open())
	{
		throw std::runtime_error(">>>> failed to open output file: " + outputFilePath);
	}

	// map to store vertex indices, 1-based indexing
	// a value of 0 indicates NoData
	std::vector<int> vertexMap(dtm.getWidth() * dtm.getHeight(), 0);

	//set precision for floating point numbers, i.e do not use scientific notation
	file << std::fixed;

	file << "# OBJ file generated by LROC DTM to Mesh Converter\n";
	file << "# Source DTM: " << dtm.getWidth() << "x" << dtm.getHeight() << " pixels\n";
	file << "# Vertical exaggeration: " << zScale << "\n\n";

	// write vertices
	std::cout << "\n>>>> [1/2] writing vertices...\n";
	auto vertices_start = std::chrono::high_resolution_clock::now();
	writeVertices(file, dtm, zScale, vertexMap);
	auto vertices_end = std::chrono::high_resolution_clock::now();
	// Calculate the duration and cast it to milliseconds for readability.
	auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(vertices_end - vertices_start);
	std::cout << ">>>> writeVertices completed in " << duration.count() << " ms.\n";

	// write faces
	std::cout << "\n>>>> [2/2] writing faces...\n";
	auto faces_start = std::chrono::high_resolution_clock::now();
	writeFaces(file, dtm, vertexMap);
	auto faces_end = std::chrono::high_resolution_clock::now();
	// Calculate the duration and cast it to milliseconds.
	duration = std::chrono::duration_cast<std::chrono::milliseconds>(faces_end - faces_start);
	std::cout << ">>>> writeFaces completed in " << duration.count() << " ms.\n";

	std::cout << ">>>> successfully generated mesh: " << outputFilePath << std::endl;
}